<!DOCTYPE html>

<style>

.container {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
}

.left-column {
    flex-basis: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
}

h1 {
    font-family: monospace;
    font-size: 32px;
}

#canvas {
    border: 1px solid #000;
    width: 800px;
    height: 800px;
}

#wireframe_button {
    min-width: 350px;
    margin: 10px auto;
    padding: 10px;

    font-family: monospace;
    font-size: 20px;
}

#tess_download_button {
    margin: 10px auto;
    padding: 10px;

    font-family: monospace;
    font-size: 20px;
}

#color_input_label {
    margin: 0px 0px 0px 20px;
    font-family: monospace;
    font-size: 20px;
}

.right-column {
    flex-basis: 50%;
    margin: 20px 0px;
}

#svg_input_label {
    font-family: monospace;
    font-size: 20px;
}

#svg_input {
    font-family: monospace;
    font-size: 20px;
}

h2 {
    font-family: monospace;
    font-size: 24px;
}

textarea {
    font-family: monospace;
    font-size: 16px;
    padding: 10px;
    border: 1px solid #000;
    width: 95%;
    box-sizing: border-box;
}

</style>

<div class="container">

    <div class="left-column">
        <h1>Canvas</h1>
        <canvas width="800" height="800" id="canvas"></canvas>

        <div>
            <button id="wireframe_button">SHOW ONLY WIREFRAME: OFF</button>

            <label for="сolor_input" id="color_input_label">Canvas background color: </label>
            <input type="color" id="сolor_input" value="#800080">
        </div>

        <button id="tess_download_button">Download tesselated mesh file</button>
    </div>

    <div class="right-column">
        
        <label for="svg_input" id="svg_input_label">Choose svg file: </label>
        <input type="file" id="svg_input" accept=".svg" />

        <br>
        <h2>SVG input:</h1>

        <textarea id="svg_in_text" rows="30" disabled="true"></textarea>

        <br>
        <h2>SVG simplified/cleaned up by <a href="https://github.com/RazrFalcon/resvg/tree/master/crates/usvg">usvg library</a>:</h1>

        <textarea id="svg_out_text" rows="30" disabled="true"></textarea>
    </div>

</div>

<script type="module">

// https://dev.w3.org/SVG/tools/svgweb/samples/svg-files/ hg0
const initial_svg =
`<svg viewBox='0 0 103 98' xmlns='http://www.w3.org/2000/svg'>
<path d='M89,71c15-26-3-68-38-64c-31,4-31,37-4,45c24,6,5,21,6,31c0,10,20,14,36-12M16,37c-5,0-8,5-8,9c1,5,5,9,10,8c5,0,8-4,8-9c-1-5-5-9-10-8' fill='#1b1a1b'/>
<circle cx='32' cy='73' fill='#1b1a1b' r='13'/>
<path d='M90,70c15-26-4-68-38-64c-31,4-32,37-4,44c23,7,5,22,5,32c1,10,21,14,37-12M17,36c-5,0-9,5-8,9c0,5,4,9,9,8c5,0,9-5,8-9c0-5-5-9-9-8' fill='#bfbfbf'/>
<circle cx='33' cy='72' fill='#bfbfbf' r='13'/>
<path d='M57,86c-1-1,1-3,2-3c3,0,8,0,12-2c10-6,25-33,17-51c-3-8-5-10-8-14c-1,0-1,0,0,0c2,1,5,5,9,11c6,11,5,24,3,32c-1,6-7,19-14,24c-8,6-17,9-21,3M50,50c-5-1-12-3-16-8c-3-4-4-8-5-11v-1c0-1,3,4,6,8c3,4,7,6,11,7c3,1,9,2,12,4c2,2,2,6,1,7c0,0-2-4-9-6M25,83c10,9,26-4,19-16l-1-1c2,7,0,12-4,15c-4,3-9,3-13,1c-1-1-2,0-1,1M13,51c0,1,1,2,2,2c1,0,4,1,8-1c4-3,4-9,2-11c0-1-1-2,0,0c1,4-2,7-4,9c-2,2-5,1-7,1c-1-1-1,0-1,0' fill='#000000'/>
<path d='M61,87c0,1,1,1,3,1c3,0,5-1,7-2c4-2,8-5,11-8c8-11,11-24,10-26c0,2-2,10-6,17c-6,9-10,14-20,17c-3,0-5-1-5,1M39,45l8,4c6,1,8,3,9,4c2,0,2,2,2,1c0-2,0-3-3-4c-1,0-4-2-6-2l-6-2l-4-1M33,85c1-1,9-3,11-9c1-2,1-2,0,0c0,5-6,9-10,9h-1M18,52c0,0,2,0,3-1c2-1,4-3,4-5v-1c0,5-4,7-6,8c-1,0-2,0-1-1' fill='#ffffff'/>
<path d='M87,53c7-19-7-48-35-44c-25,3-25,29-3,36c25,3,10,22,8,32c-2,9,20,10,30-24M24,80c2,0,3,0,4,1c4,2,9,1,12-3c3-3,3-8,2-11c-3-7-13-7-18-1c-5,7-1,14,0,14M10,47c1,1,1,2,3,2c2,1,3,2,5,1c3,0,5-3,6-5c1-3-1-5-3-7c-2-1-6-1-9,1c-2,2-3,5-2,8' fill='#999999'/>
<path d='M70,68c-7-1-16,14-7,12c9-1-9,2,0,0c4,0,8-2,11-6c5-4,11-15,13-22c1-6,1-15-1-6c-2,8-9,23-16,22M19,49c2-1,5-3,4-6c-2-2-7,0-7,3c0,3,1,3,3,3M35,81c1-1,7-3,6-11c-1-4-3,5-7,6c-6,2-5,6,1,5' fill='#f3f3f3'/>
</svg>
`;

import init, { add, tessellate_svg, simplify_svg } from './pkg/svg_alchemy.js';

await init();

const color_input = document.getElementById("сolor_input");
const tess_download_button = document.getElementById("tess_download_button");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const canvas_width = canvas.width;
const canvas_height = canvas.width;
canvas.style.backgroundColor = color_input.value;

const svg_input = document.getElementById("svg_input");

const svg_in_text = document.getElementById("svg_in_text");
const svg_out_text = document.getElementById("svg_out_text");

const wireframe_button = document.getElementById("wireframe_button");
let wireframe_enabled = false;

let current_tessellate_info = null;

wireframe_button.addEventListener("click", () => {
    wireframe_enabled = !wireframe_enabled;
    wireframe_button.textContent = wireframe_enabled ? "SHOW ONLY WIREFRAME: ON" : "SHOW ONLY WIREFRAME: FALSE";
    draw_svg_in_canvas();
});

color_input.addEventListener('input', () => {
    canvas.style.backgroundColor = color_input.value;
});

tess_download_button.addEventListener('click', () => {
    const data = gen_tessellation_file()
    const blob = new Blob([data], { type: 'text/plain' });

    { // HACK HACK HACK, idk is there alternative without 3rd party lib
        const url = window.URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'tessellation.out';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }
});

// start

{
    const uint8_view = new TextEncoder().encode(initial_svg);
    const tessellate_info = tessellate_svg(uint8_view);

    current_tessellate_info = tessellate_info;
    
    svg_in_text.value = initial_svg;
    draw_svg_in_canvas();

    const simplified_svg = simplify_svg(uint8_view);
    svg_out_text.value = new TextDecoder().decode(simplified_svg);
}

function gen_tessellation_file() {
    const indices = current_tessellate_info.indices();
    const vertices = current_tessellate_info.vertices();
    const colors = current_tessellate_info.colors();

    let final_string = "";

    final_string += `${indices.length}\n`;
    for (let i = 0; i < indices.length; i += 1) {
        final_string += `${indices[i]}\n`;
    }

    const v_count = colors.length;
    final_string += `${v_count}\n`;
    for (let i = 0; i < v_count; i += 1) {
        final_string += `${vertices[2 * i]} ${vertices[2 * i + 1]} ${colors[i]}\n`;
    }
    return final_string;
}

function draw_svg_in_canvas() {
    ctx.clearRect(0, 0, canvas_width, canvas_height);

    const indices = current_tessellate_info.indices();
    const vertices = current_tessellate_info.vertices();
    const colors = current_tessellate_info.colors();
    // const svg_width = current_tessellate_info.size_width();
    // const svg_height = current_tessellate_info.size_height();

    const view_box = current_tessellate_info.view_box();
    const view_box_width = view_box.right - view_box.left;
    const view_box_height = view_box.bottom - view_box.top;

    const scale = Math.min(canvas_width / view_box_width, canvas_height / view_box_height);
    const scale_x = scale;
    const scale_y = scale;

    const modify_x = (x) => {
        return scale_x * (x - view_box.left);
    };

    const modify_y = (y) => {
        return scale_y * (y - view_box.top);
    };

    ctx.lineWidth = 1;
    for (let i = 0; i < indices.length; i += 3) {
        const idx1 = indices[i] * 2;
        const idx2 = indices[i + 1] * 2;
        const idx3 = indices[i + 2] * 2;
        
        const x1 = modify_x(vertices[idx1]);
        const y1 = modify_y(vertices[idx1 + 1]);

        const x2 = modify_x(vertices[idx2]);
        const y2 = modify_y(vertices[idx2 + 1]);

        const x3 = modify_x(vertices[idx3]);
        const y3 = modify_y(vertices[idx3 + 1]);

        const v1_color = colors[indices[i]];
        const r = (v1_color >> 24) & 0xFF;
        const g = (v1_color >> 16) & 0xFF;
        const b = (v1_color >> 8) & 0xFF;
        const a = (v1_color & 0xFF) / 255; // Normalize alpha to a range of 0.0 to 1.0

        const rgba_color = `rgba(${r},${g},${b},${a})`;

        ctx.fillStyle = rgba_color;
        ctx.strokeStyle = rgba_color;
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        if (!wireframe_enabled) {
            ctx.fill();
        }
        ctx.stroke();
    }
}

svg_input.addEventListener("change", (change_event) => {
    const file = change_event.target.files[0];
    if (file) {
        const reader = new FileReader();
        
        reader.onload = (onload_event) => {
            const array_buffer = onload_event.target.result;
            const uint8_view = new Uint8Array(array_buffer);
            const tessellate_info = tessellate_svg(uint8_view);

            current_tessellate_info = tessellate_info;
            
            svg_in_text.value = new TextDecoder().decode(array_buffer);
            draw_svg_in_canvas();

            const simplified_svg = simplify_svg(uint8_view);
            svg_out_text.value = new TextDecoder().decode(simplified_svg);
        };
        
        reader.readAsArrayBuffer(file);
    }
});


</script>